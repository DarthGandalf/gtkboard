<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title></title>
</head>
<body>
<h1 align="center">Gtkboard developer documentation</h1>
  <font size="-1"> 
<p align="center"> This is the developer documentation for gtkboard version 0.10.0.
</p>
</font>
<h2>Gtkboard philosophy</h2>
<p>
<b>No duplication.</b>
The raison d'etre of gtkboard is to reduce the duplication of effort involved
in writing hundreds of board games. Therefore, <i>anything</i> that is common
between two or more board games must be implemented by gtkboard and available
to all games.
</p>
<p>
<b>Allow games to be created incrementally.</b>
Just because a feature exists, a game shouldn't be forced to do something about
it. Thus, when writing a new game you can concentrate on exactly what you
need and ignore the rest. For instance, you can make a new game compile and
display the board <i>without writing any code</i>, just specifying
the dimensions, colors and images for the pieces. (Several common pixmaps
are available for reuse.) Further, the user can already replay a game from a 
file -- the game doesn't need to implement anything.
</p>
<p>
<b>Homogenize.</b>
If two games require a thing to be done in slightly different ways, see if
both can be expressed as special cases of a more generic way, and the 
differences expressed in data rather than code. That way, if a new game
required the thing to be done in a third way, it is more likely that it
can be accomodated without modifying the existing code. This principle
is related to the next one.
</p>
<p>
<b>Generality is more important than efficiency.</b>
This is an application of the maxim that premature optimization is the root
of all evil. For example, the AI of some games would probably become
somwhat more efficient if the search strategy incorporated game specific
information, and the evaluation function and the move generation function
were tightly coupled. However, the extra complexity is judged to be not
worth the gain in efficiency.
</p>
<p>
<b>TIMTOWTDI.</b>
There is more than one way to do it. As far as possible, nothing will be
forced on the games. Everything is a hook. The game can choose from among
the defaults or provide its own. For example, three defaults are provided
for ordering the highscores: decreasing order of score, increasing order
of score and decreasing order of time. The game can use one of these or
write its own.
</p>
<p>
<b>Client-server model.</b>
This is the most important part. Gtkboard is currently implemented as a 
pair of processes, one for the ui and one for the number crunching, which
communicate through a pair of pipes. This has several benefits:
<ul>
<li/> Ui won't feel slow when the machine is thinking
<li/> Keeps the code clean
<li/> It is relatively easy to change the code to communicate through 
sockets and thus have network functionality.
</ul>
</p>
<p>
TODO: complete this
